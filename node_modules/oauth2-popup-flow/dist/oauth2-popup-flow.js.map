{"version":3,"sources":["webpack://OAuth2PopupFlow/webpack/universalModuleDefinition","webpack://OAuth2PopupFlow/webpack/bootstrap","webpack://OAuth2PopupFlow/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","OAuth2PopupFlow","options","this","authorizationUri","clientId","redirectUri","scope","responseType","accessTokenStorageKey","accessTokenResponseKey","storage","localStorage","pollingTime","additionalAuthorizationParameters","tokenValidator","beforePopup","afterResponse","_eventListeners","getItem","undefined","setItem","rawToken","_rawToken","encodedPayload","split","decodedPayloadJson","atob","jsonParseOrUndefined","loggedIn","decodedPayload","_rawTokenPayload","token","payload","exp","Date","getTime","tokenExpired","logout","removeItem","dispatchEvent","Event","handleRedirect","location","href","startsWith","rawHash","hash","hashMatch","exec","authorizationResponse","decodeUriToObject","addEventListener","type","listener","listeners","push","event","_i","listeners_1","length","handleEvent","removeEventListener","filter","tryLoginPopup","Promise","resolve","_a","sent","additionalParams","popup","open","encodeObjectToUri","__assign","client_id","response_type","redirect_uri","authenticated","close","time","Error","tokenPayload","json","JSON","parse","e","milliseconds","setTimeout","decodeUri","str","decodeURIComponent","obj","keys","map","encodeURIComponent","join","_this","reduce","decoded","keyValuePair","keyEncoded","valueEncoded"],"mappings":"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","file":"oauth2-popup-flow.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OAuth2PopupFlow\"] = factory();\n\telse\n\t\troot[\"OAuth2PopupFlow\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * The type of the configuration object used to create a `OAuth2PopupFlow`\n *\n * Each property has a JSDOC description to explain what it does.\n */\nexport interface OAuth2PopupFlowOptions<TokenPayload extends { exp: number }> {\n  /**\n   * REQUIRED\n   * The full URI of the authorization endpoint provided by the authorization server.\n   *\n   * e.g. `https://example.com/oauth/authorize`\n   */\n  authorizationUri: string;\n  /**\n   * REQUIRED\n   * The client ID of your application provided by the authorization server.\n   *\n   * This client ID is sent to the authorization server using `authorizationUrl` endpoint in the\n   * query portion of the URL along with the other parameters.\n   * This value will be URL encoded like so:\n   *\n   * `https://example.com/oauth/authorize?client_id=SOME_CLIENT_ID_VALUE...`\n   */\n  clientId: string;\n  /**\n   * REQUIRED\n   * The URI that the authorization server will to redirect after the user has been authenticated.\n   * This redirect URI *must* be a URI from *your application* and it must also be registered with\n   * the authorization server. Some authorities call this a \"callback URLs\" or \"login URLs\" etc.\n   *\n   * > e.g. `http://localhost:4200/redirect` for local testing\n   * >\n   * > or `https://my-application.com/redirect` for prod\n   *\n   * This redirect URI is sent to the authorization server using `authorizationUrl` endpoint in the\n   * query portion of the URL along with the other parameters.\n   * This value will be URL encoded like so:\n   *\n   * `https://example.com/oauth/authorize?redirect_URI=http%3A%2F%2Flocalhost%2Fredirect...`\n   */\n  redirectUri: string;\n  /**\n   * REQUIRED\n   * A list permission separated by spaces that is the scope of permissions your application is\n   * requesting from the authorization server. If the user is logging in the first time, it may ask\n   * them to approve those permission before authorizing your application.\n   *\n   * > e.g. `openid profile`\n   *\n   * The scopes are sent to the authorization server using `authorizationUrl` endpoint in the\n   * query portion of the URL along with the other parameters.\n   * This value will be URL encoded like so:\n   *\n   * `https://example.com/oauth/authorize?scope=openid%20profile...`\n   */\n  scope: string;\n  /**\n   * OPTIONAL\n   * `response_type` is an argument to be passed to the authorization server via the\n   * `authorizationUri` endpoint in the query portion of the URL.\n   *\n   * Most implementations of oauth2 use the default value of `token` to tell the authorization\n   * server to start the implicit grant flow but you may override that value with this option.\n   *\n   * For example, Auth0--an OAuth2 authority/authorization server--requires the value `id_token`\n   * instead of `token` for the implicit flow.\n   *\n   * The response type is sent to the authorization server using `authorizationUrl` endpoint in the\n   * query portion of the URL along with the other parameters.\n   * This value will be URL encoded like so:\n   *\n   * `https://example.com/oauth/authorize?response_type=token...`\n   */\n  responseType?: string;\n  /**\n   * OPTIONAL\n   * The key used to save the token in the given storage. The default key is `token` so the token\n   * would be persisted in `localStorage.getItem('token')` if `localStorage` was the configured\n   * `Storage`.\n   */\n  accessTokenStorageKey?: string;\n  /**\n   * OPTIONAL\n   * During `handleRedirect`, the method will try to parse `window.location.hash` to an object using\n   * `OAuth2PopupFlow.decodeUriToObject`. After that object has been decoded, this property\n   * determines the key to use that will retrieve the token from that object.\n   *\n   * By default it is `access_token` but you you may need to change that e.g. Auth0 uses `id_token`.\n   */\n  accessTokenResponseKey?: string;\n  /**\n   * OPTIONAL\n   * The storage implementation of choice. It can be `localStorage` or `sessionStorage` or something\n   * else. By default, this is `localStorage` and `localStorage` is the preferred `Storage`.\n   */\n  storage?: Storage;\n  /**\n   * OPTIONAL\n   * The `authenticated` method periodically checks `loggedIn()` and resolves when `loggedIn()`\n   * returns `true`.\n   *\n   * This property is how long it will wait between checks. By default it is `200`.\n   */\n  pollingTime?: number;\n  /**\n   * OPTIONAL\n   * Some oauth authorities require additional parameters to be passed to the `authorizationUri`\n   * URL in order for the implicit grant flow to work.\n   *\n   * For example: [Auth0--an OAuth2 authority/authorization server--requires the parameters\n   * `nonce`][0]\n   * be passed along with every call to the `authorizationUri`. You can do that like so:\n   *\n   * ```ts\n   * const auth = new OAuth2PopupFlow({\n   *   authorizationUri: 'https://example.com/oauth/authorize',\n   *   clientId: 'foo_client',\n   *   redirectUri: 'http://localhost:8080/redirect',\n   *   scope: 'openid profile',\n   *   // this can be a function or static object\n   *   additionalAuthorizationParameters: () => {\n   *     // in prod, consider something more cryptographic\n   *     const nonce = Math.floor(Math.random() * 1000).toString();\n   *     localStorage.setItem('nonce', nonce);\n   *     return { nonce };\n   *     // `nonce` will now be encoded in the URL like so:\n   *     // https://example.com/oauth/authorize?client_id=foo_client...nonce=1234\n   *   },\n   *   // the token returned by Auth0, has the `nonce` in the payload\n   *   // you can add this additional check now\n   *   tokenValidator: ({ payload }) => {\n   *     const storageNonce = parseInt(localStorage.getItem('nonce'), 10);\n   *     const payloadNonce = parseInt(payload.nonce, 10);\n   *     return storageNonce === payloadNonce;\n   *   },\n   * });\n   * ```\n   *\n   * [0]: https://auth0.com/docs/api-auth/tutorials/nonce#generate-a-cryptographically-random-nonce\n   */\n  additionalAuthorizationParameters?: (() => { [key: string]: string }) | { [key: string]: string };\n  /**\n   * OPTIONAL\n   * This function intercepts the `loggedIn` method and causes it to return early with `false` if\n   * this function itself returns `false`. Use this function to validate claims in the token payload\n   * or token.\n   *\n   * [For example: validating the `nonce`:][0]\n   *\n   * ```ts\n   * const auth = new OAuth2PopupFlow({\n   *   authorizationUri: 'https://example.com/oauth/authorize',\n   *   clientId: 'foo_client',\n   *   redirectUri: 'http://localhost:8080/redirect',\n   *   scope: 'openid profile',\n   *   // this can be a function or static object\n   *   additionalAuthorizationParameters: () => {\n   *     // in prod, consider something more cryptographic\n   *     const nonce = Math.floor(Math.random() * 1000).toString();\n   *     localStorage.setItem('nonce', nonce);\n   *     return { nonce };\n   *     // `nonce` will now be encoded in the URL like so:\n   *     // https://example.com/oauth/authorize?client_id=foo_client...nonce=1234\n   *   },\n   *   // the token returned by Auth0, has the `nonce` in the payload\n   *   // you can add this additional check now\n   *   tokenValidator: ({ payload }) => {\n   *     const storageNonce = parseInt(localStorage.getItem('nonce'), 10);\n   *     const payloadNonce = parseInt(payload.nonce, 10);\n   *     return storageNonce === payloadNonce;\n   *   },\n   * });\n   * ```\n   *\n   * [0]: https://auth0.com/docs/api-auth/tutorials/nonce#generate-a-cryptographically-random-nonce\n   */\n  tokenValidator?: (options: { payload: TokenPayload; token: string }) => boolean;\n  /**\n   * OPTIONAL\n   * A hook that runs in `tryLoginPopup` before any popup is opened. This function can return a\n   * `Promise` and the popup will not open until it resolves.\n   *\n   * A typical use case would be to wait a certain amount of time before opening the popup to let\n   * the user see why the popup is happening.\n   */\n  beforePopup?: () => any | Promise<any>;\n  /**\n   * OPTIONAL\n   * A hook that runs in `handleRedirect` that takes in the result of the hash payload from the\n   * authorization server. Use this hook to grab more from the response or to debug the response\n   * from the authorization URL.\n   */\n  afterResponse?: (authorizationResponse: { [key: string]: string | undefined }) => void;\n}\n\nexport class OAuth2PopupFlow<TokenPayload extends { exp: number }> implements EventTarget {\n  authorizationUri: string;\n  clientId: string;\n  redirectUri: string;\n  scope: string;\n  responseType: string;\n  accessTokenStorageKey: string;\n  accessTokenResponseKey: string;\n  storage: Storage;\n  pollingTime: number;\n  additionalAuthorizationParameters?: (() => { [key: string]: string }) | { [key: string]: string };\n  tokenValidator?: (options: { payload: TokenPayload; token: string }) => boolean;\n  beforePopup?: () => any | Promise<any>;\n  afterResponse?: (authorizationResponse: { [key: string]: string | undefined }) => void;\n  private _eventListeners: {\n    [type: string]: EventListenerOrEventListenerObject[];\n  };\n\n  constructor(options: OAuth2PopupFlowOptions<TokenPayload>) {\n    this.authorizationUri = options.authorizationUri;\n    this.clientId = options.clientId;\n    this.redirectUri = options.redirectUri;\n    this.scope = options.scope;\n    this.responseType = options.responseType || 'token';\n    this.accessTokenStorageKey = options.accessTokenStorageKey || 'token';\n    this.accessTokenResponseKey = options.accessTokenResponseKey || 'access_token';\n    this.storage = options.storage || window.localStorage;\n    this.pollingTime = options.pollingTime || 200;\n    this.additionalAuthorizationParameters = options.additionalAuthorizationParameters;\n    this.tokenValidator = options.tokenValidator;\n    this.beforePopup = options.beforePopup;\n    this.afterResponse = options.afterResponse;\n    this._eventListeners = {};\n  }\n\n  private get _rawToken() {\n    return this.storage.getItem(this.accessTokenStorageKey) || undefined;\n  }\n  private set _rawToken(value: string | undefined) {\n    if (value === null) return;\n    if (value === undefined) return;\n\n    this.storage.setItem(this.accessTokenStorageKey, value);\n  }\n\n  private get _rawTokenPayload() {\n    const rawToken = this._rawToken;\n    if (!rawToken) return undefined;\n\n    const tokenSplit = rawToken.split('.');\n    const encodedPayload = tokenSplit[1];\n    if (!encodedPayload) return undefined;\n\n    const decodedPayloadJson = window.atob(encodedPayload);\n    const decodedPayload = OAuth2PopupFlow.jsonParseOrUndefined<TokenPayload>(decodedPayloadJson);\n    return decodedPayload;\n  }\n\n  /**\n   * A simple synchronous method that returns whether or not the user is logged in by checking\n   * whether or not their token is present and not expired.\n   */\n  loggedIn() {\n    const decodedPayload = this._rawTokenPayload;\n    if (!decodedPayload) return false;\n\n    if (this.tokenValidator) {\n      const token = this._rawToken!;\n      if (!this.tokenValidator({ payload: decodedPayload, token })) return false;\n    }\n\n    const exp = decodedPayload.exp;\n    if (!exp) return false;\n\n    if (new Date().getTime() > exp * 1000) return false;\n    return true;\n  }\n\n  /**\n   * Returns true only if there is a token in storage and that token is expired. Use this to method\n   * in conjunction with `loggedIn` to display a message like \"you need to *re*login\" vs \"you need\n   * to login\".\n   */\n  tokenExpired() {\n    const decodedPayload = this._rawTokenPayload;\n    if (!decodedPayload) return false;\n\n    const exp = decodedPayload.exp;\n    if (!exp) return false;\n\n    if (new Date().getTime() <= exp * 1000) return false;\n\n    return true;\n  }\n\n  /**\n   * Deletes the token from the given storage causing `loggedIn` to return false on its next call.\n   * Also dispatches `logout` event\n   */\n  logout() {\n    this.storage.removeItem(this.accessTokenStorageKey);\n    this.dispatchEvent(new Event('logout'));\n  }\n\n  /**\n   * Call this method in a route of the `redirectUri`. This method takes the value of the hash at\n   * `window.location.hash` and attempts to grab the token from the URL.\n   *\n   * If the method was able to grab the token, it will return `'SUCCESS'` else it will return a\n   * different string.\n   */\n  handleRedirect() {\n    const locationHref = window.location.href;\n    if (!locationHref.startsWith(this.redirectUri)) return 'REDIRECT_URI_MISMATCH';\n\n    const rawHash = window.location.hash;\n    if (!rawHash) return 'FALSY_HASH';\n    const hashMatch = /#(.*)/.exec(rawHash);\n\n    // this case won't happen because the browser typically adds the `#` always\n    if (!hashMatch) return 'NO_HASH_MATCH';\n    const hash = hashMatch[1];\n\n    const authorizationResponse = OAuth2PopupFlow.decodeUriToObject(hash);\n    if (this.afterResponse) {\n      this.afterResponse(authorizationResponse);\n    }\n    const rawToken = authorizationResponse[this.accessTokenResponseKey];\n    if (!rawToken) return 'FALSY_TOKEN';\n\n    this._rawToken = rawToken;\n    window.location.hash = '';\n    return 'SUCCESS';\n  }\n\n  /**\n   * supported events are:\n   *\n   * 1. `logout`–fired when the `logout()` method is called and\n   * 2. `login`–fired during the `tryLoginPopup()` method is called and succeeds\n   */\n  addEventListener(type: string, listener: EventListenerOrEventListenerObject) {\n    const listeners = this._eventListeners[type] || [];\n    listeners.push(listener);\n    this._eventListeners[type] = listeners;\n  }\n\n  /**\n   * Use this to dispatch an event to the internal `EventTarget`\n   */\n  dispatchEvent(event: Event) {\n    const listeners = this._eventListeners[event.type] || [];\n    for (const listener of listeners) {\n      const dispatch =\n        typeof listener === 'function'\n          ? listener\n          : typeof listener === 'object' && typeof listener.handleEvent === 'function'\n          ? listener.handleEvent.bind(listener)\n          : () => {};\n\n      dispatch(event);\n    }\n    return true;\n  }\n\n  /**\n   * Removes the event listener in target's event listener list with the same type, callback, and options.\n   */\n  removeEventListener(type: string, listener: EventListenerOrEventListenerObject) {\n    const listeners = this._eventListeners[type] || [];\n    this._eventListeners[type] = listeners.filter(l => l !== listener);\n  }\n\n  /**\n   * Tries to open a popup to login the user in. If the user is already `loggedIn()` it will\n   * immediately return `'ALREADY_LOGGED_IN'`. If the popup fails to open, it will immediately\n   * return `'POPUP_FAILED'` else it will wait for `loggedIn()` to be `true` and eventually\n   * return `'SUCCESS'`.\n   *\n   * Also dispatches `login` event\n   */\n  async tryLoginPopup() {\n    if (this.loggedIn()) return 'ALREADY_LOGGED_IN';\n\n    if (this.beforePopup) {\n      await Promise.resolve(this.beforePopup());\n    }\n\n    const additionalParams =\n      typeof this.additionalAuthorizationParameters === 'function'\n        ? this.additionalAuthorizationParameters()\n        : typeof this.additionalAuthorizationParameters === 'object'\n        ? this.additionalAuthorizationParameters\n        : {};\n\n    const popup = window.open(\n      `${this.authorizationUri}?${OAuth2PopupFlow.encodeObjectToUri({\n        client_id: this.clientId,\n        response_type: this.responseType,\n        redirect_uri: this.redirectUri,\n        scope: this.scope,\n        ...additionalParams,\n      })}`,\n    );\n    if (!popup) return 'POPUP_FAILED';\n\n    await this.authenticated();\n    popup.close();\n    this.dispatchEvent(new Event('login'));\n\n    return 'SUCCESS';\n  }\n\n  /**\n   * A promise that does not resolve until `loggedIn()` is true. This uses the `pollingTime`\n   * to wait until checking if `loggedIn()` is `true`.\n   */\n  async authenticated() {\n    while (!this.loggedIn()) {\n      await OAuth2PopupFlow.time(this.pollingTime);\n    }\n  }\n\n  /**\n   * If the user is `loggedIn()`, the token will be returned immediate, else it will open a popup\n   * and wait until the user is `loggedIn()` (i.e. a new token has been added).\n   */\n  async token() {\n    await this.authenticated();\n    const token = this._rawToken;\n    if (!token) throw new Error('Token was falsy after being authenticated.');\n    return token;\n  }\n\n  /**\n   * If the user is `loggedIn()`, the token payload will be returned immediate, else it will open a\n   * popup and wait until the user is `loggedIn()` (i.e. a new token has been added).\n   */\n  async tokenPayload() {\n    await this.authenticated();\n    const payload = this._rawTokenPayload;\n    if (!payload) throw new Error('Token payload was falsy after being authenticated.');\n    return payload;\n  }\n\n  /**\n   * wraps `JSON.parse` and return `undefined` if the parsing failed\n   */\n  static jsonParseOrUndefined<T = {}>(json: string) {\n    try {\n      return JSON.parse(json) as T;\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  /**\n   * wraps `setTimeout` in a `Promise` that resolves to `'TIMER'`\n   */\n  static time(milliseconds: number) {\n    return new Promise<'TIMER'>(resolve => window.setTimeout(() => resolve('TIMER'), milliseconds));\n  }\n\n  /**\n   * wraps `decodeURIComponent` and returns the original string if it cannot be decoded\n   */\n  static decodeUri(str: string) {\n    try {\n      return decodeURIComponent(str);\n    } catch (e) {\n      return str;\n    }\n  }\n\n  /**\n   * Encodes an object of strings to a URL\n   *\n   * `{one: 'two', buckle: 'shoes or something'}` ==> `one=two&buckle=shoes%20or%20something`\n   */\n  static encodeObjectToUri(obj: { [key: string]: string }) {\n    return Object.keys(obj)\n      .map(key => ({ key, value: obj[key] }))\n      .map(({ key, value }) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\n      .join('&');\n  }\n\n  /**\n   * Decodes a URL string to an object of string\n   *\n   * `one=two&buckle=shoes%20or%20something` ==> `{one: 'two', buckle: 'shoes or something'}`\n   */\n  static decodeUriToObject(str: string) {\n    return str.split('&').reduce(\n      (decoded, keyValuePair) => {\n        const [keyEncoded, valueEncoded] = keyValuePair.split('=');\n        const key = this.decodeUri(keyEncoded);\n        const value = this.decodeUri(valueEncoded);\n        decoded[key] = value;\n        return decoded;\n      },\n      {} as { [key: string]: string | undefined },\n    );\n  }\n}\n"],"sourceRoot":""}